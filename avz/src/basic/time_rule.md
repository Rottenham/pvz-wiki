<!--
 * @Coding: utf-8
 * @Author: vector-wlc
 * @Date: 2021-09-25 16:01:21
 * @Description: 
-->
# 时间设定

由于使用了操作队列，AvZ 关于时间的操作十分自由，几乎不受任何约束，可以写的随心所欲 。后续将会介绍什么是操作队列，以及如何更高级的使用操作队列，现在只介绍操作队列中的一环——时间设定。

首先，时间设定主要是由函数 `SetTime` 实现的，具体使用如下：
```C++
SetTime(-599, 1);
Card(LILY_PAD, 3, 4);
```

这样书写后，脚本将会在第一波刷新前 599cs 在三行四列种下荷叶，看起来很简单，但实际上 `SetTime` 的使用也许比你想象的更加灵活，下面通过与其他框架的对比体现这一点。

在其他框架中有关时间设置的函数全部是阻塞函数，即只有到达指定的时间点时，时间函数之后的语句才能运行，这样带来的一些令人头疼的问题，就是每次写代码的时候还得用计算器计算时间先后顺序，例如以下代码运行是会报出错误的，错误大致是：时刻点 200 已过去

```C++
Prejudge(300, 1);
Card(1, 1, 1);
Until(200);
Card(3, 2, 1);
```

报错的原因就是因为阻塞，由于时间点已经到达了第一波刷新后 300cs ，所以再使用 `Until(200)` 是不符合逻辑的，因为时间不能倒流。但是在 AvZ 中这种写法是允许的，例如下面的代码：
```C++
SetTime(300, 1);
Card(1, 1, 1);
SetTime(200);
Card(3, 2, 1);
```

是完全正确的，注意，第二个 `SetTime` 并没有填写第二个指定波数的参数，如果没有填写第二个指定波数的参数，那么此时 `SetTime` 设定的波数将会与上一次调用时填写的波数相同，除了 `SetTime` 函数，AvZ 中还有一个时间设定函数 `Delay`，令人兴奋的是，`Delay` 函数参数可以填写为负值，意思就是提前，例如：
```C++
SetTime(300, 1);
Card(1, 1, 1);
SetTime(200);
Card(3, 2, 1);
Delay(-10);
Card(2, 3, 1);
```

这样写在 AvZ 中是允许的，但是在使用 `Delay` 之前必须使用 `SetTime`，因为 `Delay` 需要知道延迟的基准时间是什么。

总之，AvZ 中的时间设定非常人性化，使用者可以完全不用考虑时间先后的问题，只需要注意自己是否将时间点设定正确即可。


[上一篇 卡片操作](./card.md)

[目录](../catalogue.md)

[下一篇 存冰类](./ice_filler.md)